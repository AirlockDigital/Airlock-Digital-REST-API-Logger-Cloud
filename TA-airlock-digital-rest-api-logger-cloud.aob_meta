{"basic_builder": {"appname": "TA-airlock-digital-rest-api-logger-cloud", "friendly_name": "Airlock Digital REST API Logger Cloud", "version": "1.0.5", "author": "DavidCottingham", "description": "Ingests Agent, File Execution and Server Activity History logs from an Airlock Digital server via the rest API. This version is for Splunk Cloud and removes the option to toggle TLS certificate validation.", "theme": "#3c6188", "large_icon": "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", "small_icon": "iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAAXNSR0IArs4c6QAABD9JREFUWEfNmE9s22QYxp/XSf9srdu1jI0LAiaBYBtcEMdJFUgcSCgCie0yMW7bkIir2KHxQCgCrW7XOKrHYdsJBkKCTQKxJRyQQBPihrgMOhBIA8SFjalb65S2SeMXJVHS2HHiz+0OfIdItp/neX/6/H7fZ4XwPxu0VZ5s9tzOdaw8Ws2JYtsvmnb01lYywwKRkbWOgnAaQE9A4TIYCV1TzgFgUUhhoGnTusbAY6LBrToCfk6ryl4RbyDQSXPusAT6SCQsUMN0WNcSH3fTdQWazlrXmfBQYKEQAmL8ntaUPZ0sHYGmTOsPAh7wMxKh7FT4+ALKn2RTqeVWjTY7O3CPFD1EJJ1l9u8zBv48oSoP+mb73Zwy524S6F6fZ8tr9u0dmUxmXWRSMplMtE8euQNgwKtn8D8n1Ild3vttM2Tk5lJgOuVT8G1dVd4VAfFqpnNzbzFTm5eAVFpVsp4F4LYbptW2RB2ncujNVPLCZmAanpOzuYOSFPnUm6GrimtSXBdGdu4OiIZdxBV6Lf1G4sxWYBpeI2sdA8GdxbyoaxM7Gpom0MzMjOxE+5c8hW/oqnLf3YBpQpnW3wB2t2ZK66tDk5OTdvVeE8gwrc8AvNgq1FVFCrPLCoKTYVqOR/u5rioveYE8vUPzuprYL1gklMwwrR8BuLIbvdQ6Qy4gKlf2p9PJ+VCVBMXvTOf29fREfvK8jRpL7WfqVO4ARSLf+gkEa4SWeVczMR9IaxPf1YCmzdPnGfxKS2pFV5Vo6CohDIZpVTfXyMbqog/TauJIHSiX28eOtL2Z10OOrig/hMgPLTUs60mUubpoaoMk5990MjkfeNqHrrRFQw1oMGZ+Q4Sxbll20e7FFbEzrC1nLBOVB+VSt3xmXCkW1KdrQHLM1ECY7WZwHHpi+ctkdbmGHgPP5R6XJL7a1cik2YWkWX9lezO98h55LaCSY+fVZhOGoZLjpquB/bz2dbsP1zKlZg/JcTPwu5cQfWQpr/wWBmYobj3MWP81yGPn1Y19qNZHcXONgN5gY1ICKBC+nsMkx3PeY6KtBAOlYl7tq622xlM5Zo6D8EUQUPW5xKXRxYJ+u5t2OGaMONS7IJIH0LidT152AdWaW+C1bRTg7/ukyjO3LtVP6cbYOT4jrzmRrwF6SgwGaLyudqAQs+Quxqv1a+oXhWjqGC/YBfVS47ptY5Tj5iKAodDBmzEwluyC6v4gbMupb2LlzeSH9dhFu8e72fofHTFjRBZuyLAYdb3NpVH4LIyOZ9ngs7O7qFe6sbly3V1ccnYXv0rd9FN1P1zH3u+XBxaWQIF/LIhxM8r2dhrGxeRKJ4PQaS/Hsh+A6IhY1Q4q5vN2QXs1KEMIqBEyGM+eIdCxoNDW5ww6W8wnj4t6QgE1Q1++EBla+es9Zn6eSRolcG3/YdAqsbNARJeXtt3/Oi4erIiCdNyHwgbcbf1/Q2NiNGOyteAAAAAASUVORK5CYII=", "visible": true, "tab_version": "4.0.0", "tab_build_no": "0", "build_no": 1}, "data_input_builder": {"datainputs": [{"index": "default", "sourcetype": "airlockagent", "interval": "86400", "use_external_validation": true, "streaming_mode_xml": true, "name": "airlockagent", "title": "airlockagent", "description": "Retrieves the agent listing from an Airlock Server via the REST API", "type": "customized", "parameters": [{"required": true, "name": "endpoint", "label": "Endpoint", "default_value": "/v1/agent/find", "placeholder": "/v1/agent/find", "help_string": "Note: This value typically does not need to be modified", "type": "text", "format_type": "text", "value": "/v1/agent/find"}], "data_inputs_options": [{"type": "customized_var", "name": "endpoint", "title": "Endpoint", "description": "Note: This value typically does not need to be modified", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "/v1/agent/find", "placeholder": "/v1/agent/find"}], "code": "# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport datetime\nimport json\n\ndef validate_input(helper, definition):\n    pass\n\ndef collect_events(helper, ew):\n\n    # The following examples get the arguments of this input.\n    # Note, for single instance mod input, args will be returned as a dict.\n    # For multi instance mod input, args will be returned as a single value.\n    opt_airlock_server_fqdn = helper.get_global_setting('airlock_server_fqdn')\n    opt_airlock_rest_api_port = helper.get_global_setting('airlock_rest_api_port')\n    opt_airlock_rest_api_key = helper.get_global_setting('airlock_rest_api_key')\n    #opt_verify_remote_tls_certificate = helper.get_global_setting('verify_remote_tls_certificate')    \n    helper.get_input_stanza()\n    # The following examples get options from setup page configuration.\n    # get the loglevel from the setup page\n    #loglevel = helper.get_log_level()\n    # get proxy setting configuration\n    proxy_settings = helper.get_proxy()\n    # get account credentials as dictionary\n    #account = helper.get_user_credential_by_username(\"username\")\n    #account = helper.get_user_credential_by_id(\"account id\")\n    # get global variable configuration\n    #global_userdefined_global_var = helper.get_global_setting(\"userdefined_global_var\")\n\n    #helper.set_log_level(log_level)\n\n    # The following examples send rest requests to some endpoint.\n    response = helper.send_http_request(\"https://\" + opt_airlock_server_fqdn +\":\"+opt_airlock_rest_api_port+\"/v1/agent/find\", method=\"POST\", parameters=None, headers={\"X-ApiKey\":opt_airlock_rest_api_key}, cookies=None, verify=True, cert=None,timeout=None, use_proxy=True)\n\n    r_json = response.json()\n\n    # check the response status, if the status is not sucessful, raise requests.HTTPError\n    response.raise_for_status()\n\n\n    for i in r_json['response']['agents']:\n        agents=i\n        event = helper.new_event(source=\"Airlock_Agent\", index=helper.get_output_index(), sourcetype=\"_json\", data=json.dumps(agents),unbroken=True,time=time.time())\n        ew.write_event(event)", "customized_options": [{"name": "endpoint", "value": "/v1/agent/find"}], "uuid": "5ae23ee1fd6148f5acfa973083652e5d"}, {"index": "default", "sourcetype": "svractivities", "interval": "30", "use_external_validation": true, "streaming_mode_xml": true, "name": "svractivities", "title": "svractivities", "description": "Retrieves the Server Activity History from an Airlock Server via the REST API", "type": "customized", "parameters": [{"required": false, "name": "delete_existing_checkpoint", "label": "Delete Existing Checkpoint", "default_value": false, "help_string": "When checked will delete the existing checkpoint stored in Splunk and exit. This used for troubleshooting purposes only and the utility will not index events while this option is selected.", "type": "checkbox", "format_type": "checkbox", "value": false}], "data_inputs_options": [{"type": "customized_var", "name": "delete_existing_checkpoint", "title": "Delete Existing Checkpoint", "description": "When checked will delete the existing checkpoint stored in Splunk and exit. This used for troubleshooting purposes only and the utility will not index events while this option is selected.", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}], "code": "\n# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport datetime\nimport json\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    pass\n\ndef collect_events(helper, ew):\n    \"\"\"Implement your data collection logic here\"\"\"\n\n    # The following examples get the arguments of this input.\n    # Note, for single instance mod input, args will be returned as a dict.\n    # For multi instance mod input, args will be returned as a single value.\n    opt_airlock_server_fqdn = helper.get_global_setting('airlock_server_fqdn')\n    opt_airlock_rest_api_port = helper.get_global_setting('airlock_rest_api_port')\n    opt_airlock_rest_api_key = helper.get_global_setting('airlock_rest_api_key')\n    #opt_verify_remote_tls_certificate = helper.get_global_setting('verify_remote_tls_certificate')\n    opt_delete_existing_checkpoint = helper.get_arg('delete_existing_checkpoint')\n    \n    if opt_delete_existing_checkpoint is True:\n        helper.delete_check_point(\"svrcheckpoint\")\n        helper.log_debug(\"Existing checkpoint deleted, now exiting. Disable the Delete Existing Checkpoint option to index logs\")\n        exit()    \n    # The following examples get options from setup page configuration.\n    # get proxy setting configuration\n    proxy_settings = helper.get_proxy()\n    # get account credentials as dictionary\n    #account = helper.get_user_credential_by_username(\"username\")\n    #account = helper.get_user_credential_by_id(\"account id\")\n    # get global variable configuration\n    #global_userdefined_global_var = helper.get_global_setting(\"userdefined_global_var\")\n    # get checkpoint\n    svrcheckpoint = helper.get_check_point(\"svrcheckpoint\")\n    try:\n        helper.log_debug(\"Checkpoint value in Splunk is:\" + svrcheckpoint)\n    except:\n        helper.log_debug(\"Checkpoint appears to be empty\")\n    # The following examples send rest requests to some endpoint.\n    if svrcheckpoint is None:\n        helper.log_debug(\"No historical checkpoint found, obtaining restart checkpoint from Airlock\") \n\n        response = helper.send_http_request(\"https://\" + opt_airlock_server_fqdn +\":\"+opt_airlock_rest_api_port+\"/v1/logging/svractivities\", method=\"POST\", parameters=None, payload=None,headers={\"X-ApiKey\":opt_airlock_rest_api_key}, cookies=None, verify=True, cert=None,timeout=None, use_proxy=True)\n        response.raise_for_status()\n        r_json = response.json()        \n        if not 'response' in r_json or len(r_json['response']['svractivities']) == 0: #If there are no results we don't need to write anything or do much\n            helper.log_debug(\"Something went wrong sending the request to the Airlock Server, please check connectivity. Unable to get initial checkpoint.\")\n            exit() #Stop here because we can't continue\n            \n        else:\n            r_json = response.json()\n            helper.log_debug(r_json)\n            svrcheckpoint = r_json['response']['svractivities'][-1]['checkpoint']\n            #Write the events to the specified index\n            event = helper.new_event(source=\"Airlock_REST_svractivities\", sourcetype=\"_json\", index=\"main\", data=json.dumps(r_json['response']['svractivities']))\n            #replace hardcoded index with index=helper.get_output_index()\n            # save checkpoint\n            helper.log_debug(\"Saving checkpoint to Splunk:\" + svrcheckpoint)\n            helper.save_check_point(\"svrcheckpoint\", svrcheckpoint)\n\n    else:\n        helper.log_debug(\"Historical checkpoint found:\" + svrcheckpoint)\n        try:\n            response = helper.send_http_request(\"https://\" + opt_airlock_server_fqdn +\":\"+opt_airlock_rest_api_port+\"/v1/logging/svractivities\", method=\"POST\", parameters=None, payload={\"checkpoint\":svrcheckpoint},headers={\"X-ApiKey\":opt_airlock_rest_api_key}, cookies=None, verify=True, cert=None,timeout=None, use_proxy=True)\n            response.raise_for_status()\n            r_json = response.json()\n        except:\n            helper.log_info(\"Something went wrong sending the request to the Airlock Server, please check connectivity and that the supplied REST API key is valid. Please enable debug logging to see more information. If Access Forbidden is seen on debug level logging, the API key is invalid.\")\n            r_json = response.json()\n            helper.log_debug(r_json)\n            exit() #If the request is unable to be sent we should quit here\n            \n        if not 'response' in r_json or len(r_json['response']['svractivities']) == 0: #If there are no results we don't need to write anything or do much\n            helper.log_debug(\"no results, nothing to do\")\n        else:    \n            helper.log_debug(\"there are results to parse\")\n            helper.log_debug(r_json)\n            #Write the events to the specified index\n            for i in r_json['response']['svractivities']:\n                event = helper.new_event(source=\"Airlock_REST_svractivities\", sourcetype=\"_json\", index=helper.get_output_index(), data=json.dumps(i))\n                ew.write_event(event)\n\n            #Set latest checkpoint\n            svrcheckpoint = r_json['response']['svractivities'][-1]['checkpoint']\n            # save checkpoint\n            helper.log_info(\"Saving checkpoint to Splunk:\" + svrcheckpoint)\n            helper.save_check_point(\"svrcheckpoint\", svrcheckpoint)\n\n\n\n", "customized_options": [{"name": "delete_existing_checkpoint", "value": false}], "uuid": "f6a9e8c354d94d16a088a1d6a7212131"}, {"index": "default", "sourcetype": "exechistories", "interval": "30", "use_external_validation": true, "streaming_mode_xml": true, "name": "exechistories", "title": "exechistories", "description": "Retrieves the execution history of files from an Airlock Server via the REST API", "type": "customized", "parameters": [{"required": true, "name": "execution_types_to_collect", "label": "Execution Types to Collect", "default_value": ["0", "1", "2", "3", "4", "5", "6", "7", "8"], "help_string": "", "placeholder": "", "possible_values": [{"value": "0", "label": "Trusted Execution"}, {"value": "1", "label": "Blocked Execution"}, {"value": "2", "label": "Untrusted Execution [Audit]"}, {"label": "Untrusted Execution [OTP]", "value": "3"}, {"label": "Trusted Path Execution", "value": "4"}, {"label": "Trusted Publisher Execution", "value": "5"}, {"label": "Blocklist Execution", "value": "6"}, {"label": "Blocklist Execution [Audit]", "value": "7"}, {"label": "Trusted Process Execution", "value": "8"}], "type": "multi_dropdownlist", "format_type": "multi_dropdownlist", "value": ["0", "1", "2", "3", "4", "5", "6", "7", "8"]}, {"required": false, "name": "delete_existing_checkpoint", "label": "Delete Existing Checkpoint", "default_value": false, "help_string": "When checked will delete the existing checkpoint stored in Splunk and exit. This used for troubleshooting purposes only and the utility will not index events while this option is selected.", "type": "checkbox", "format_type": "checkbox", "value": false}], "data_inputs_options": [{"type": "customized_var", "name": "execution_types_to_collect", "title": "Execution Types to Collect", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [{"value": "0", "label": "Trusted Execution"}, {"value": "1", "label": "Blocked Execution"}, {"value": "2", "label": "Untrusted Execution [Audit]"}, {"label": "Untrusted Execution [OTP]", "value": "3"}, {"label": "Trusted Path Execution", "value": "4"}, {"label": "Trusted Publisher Execution", "value": "5"}, {"label": "Blocklist Execution", "value": "6"}, {"label": "Blocklist Execution [Audit]", "value": "7"}, {"label": "Trusted Process Execution", "value": "8"}], "format_type": "multi_dropdownlist", "default_value": ["0", "1", "2", "3", "4", "5", "6", "7", "8"], "placeholder": ""}, {"type": "customized_var", "name": "delete_existing_checkpoint", "title": "Delete Existing Checkpoint", "description": "When checked will delete the existing checkpoint stored in Splunk and exit. This used for troubleshooting purposes only and the utility will not index events while this option is selected.", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": false}], "code": "\n# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport datetime\nimport json\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    pass\n\ndef collect_events(helper, ew):\n    \"\"\"Implement your data collection logic here\"\"\"\n\n    # The following examples get the arguments of this input.\n    # Note, for single instance mod input, args will be returned as a dict.\n    # For multi instance mod input, args will be returned as a single value.\n    opt_airlock_server_fqdn = helper.get_global_setting('airlock_server_fqdn')\n    opt_airlock_rest_api_port = helper.get_global_setting('airlock_rest_api_port')\n    opt_airlock_rest_api_key = helper.get_global_setting('airlock_rest_api_key')\n    #opt_verify_remote_tls_certificate = helper.get_global_setting('verify_remote_tls_certificate')\n    opt_execution_types_to_collect = helper.get_arg('execution_types_to_collect')\n    opt_delete_existing_checkpoint = helper.get_arg('delete_existing_checkpoint')\n    if opt_delete_existing_checkpoint is True:\n        helper.delete_check_point(\"checkpoint\")\n        helper.log_debug(\"Existing checkpoint deleted, now exiting. Disable the Delete Existing Checkpoint option to index logs\")\n        exit()\n    # The following examples get options from setup page configuration.\n    # get proxy setting configuration\n    proxy_settings = helper.get_proxy()\n    # get account credentials as dictionary\n    #account = helper.get_user_credential_by_username(\"username\")\n    #account = helper.get_user_credential_by_id(\"account id\")\n    # get global variable configuration\n    #global_userdefined_global_var = helper.get_global_setting(\"userdefined_global_var\")\n    # get checkpoint\n    checkpoint = helper.get_check_point(\"checkpoint\")\n    try:\n        helper.log_debug(\"Checkpoint value in Splunk is:\" + checkpoint)\n    except:\n        helper.log_debug(\"Checkpoint appears to be empty\")\n    # The following examples send rest requests to some endpoint.\n    if checkpoint is None:\n        helper.log_debug(\"No historical checkpoint found, obtaining restart checkpoint from Airlock\") \n\n        response = helper.send_http_request(\"https://\"+opt_airlock_server_fqdn +\":\"+opt_airlock_rest_api_port+\"/v1/logging/exechistories\", method=\"POST\", parameters=None, payload={\"type\":opt_execution_types_to_collect},headers={\"X-ApiKey\":opt_airlock_rest_api_key}, cookies=None, verify=True, cert=None,timeout=None, use_proxy=True)\n        response.raise_for_status()\n        r_json = response.json()        \n        if not 'response' in r_json or len(r_json['response']['exechistories']) == 0: #If there are no results we don't need to write anything or do much\n            helper.log_info(\"Something went wrong sending the request to the Airlock Server, please check connectivity and your API key. Unable to get initial checkpoint.\")\n            exit() #Stop here because we can't continue\n            \n        else:\n            r_json = response.json()\n            helper.log_debug(r_json)\n            checkpoint = r_json['response']['exechistories'][-1]['checkpoint']\n            #Write the events to the specified index\n            event = helper.new_event(source=\"Airlock_REST_exechistories\", sourcetype=\"_json\", index=\"main\", data=json.dumps(r_json['response']['exechistories']))\n            #replace hardcoded index with index=helper.get_output_index()\n            # save checkpoint\n            helper.log_debug(\"Saving checkpoint to Splunk:\" + checkpoint)\n            helper.save_check_point(\"checkpoint\", checkpoint)\n\n    else:\n        helper.log_debug(\"Historical checkpoint found:\" + checkpoint)\n        try:\n            response = helper.send_http_request(\"https://\"+opt_airlock_server_fqdn +\":\"+opt_airlock_rest_api_port+\"/v1/logging/exechistories\", method=\"POST\", parameters=None, payload={\"checkpoint\":checkpoint,\"type\":opt_execution_types_to_collect},headers={\"X-ApiKey\":opt_airlock_rest_api_key}, cookies=None, verify=True, cert=None,timeout=None, use_proxy=True)\n            response.raise_for_status()\n            r_json = response.json()\n        except:\n            helper.log_info(\"Something went wrong sending the request to the Airlock Server, please check connectivity and your API key for validity.\")\n            exit() #If the request is unable to be sent we should quit here\n            \n        if not 'response' in r_json or len(r_json['response']['exechistories']) == 0: #If there are no results we don't need to write anything or do much\n            helper.log_debug(\"no results, nothing to do\")\n        else:    \n            helper.log_debug(\"there are results to parse\")\n            helper.log_debug(r_json)\n            #Write the events to the specified index\n            for i in r_json['response']['exechistories']:\n                event = helper.new_event(source=\"Airlock_REST_exechistories\", sourcetype=\"_json\", index=helper.get_output_index(), data=json.dumps(i))\n                ew.write_event(event)\n            index=helper.get_output_index()\n            helper.log_debug(\"index is\" + index)\n            #Set latest checkpoint\n            checkpoint = r_json['response']['exechistories'][-1]['checkpoint']\n            # save checkpoint\n            helper.log_info(\"Saving checkpoint to Splunk:\" + checkpoint)\n            helper.save_check_point(\"checkpoint\", checkpoint)\n\n\n\n", "customized_options": [{"name": "execution_types_to_collect", "value": ["0", "1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "delete_existing_checkpoint", "value": false}], "uuid": "460e7194ad7441dfb762ca7ec23a83da"}, {"index": "default", "sourcetype": "airlockpolicies", "interval": "86400", "use_external_validation": true, "streaming_mode_xml": true, "name": "airlockpolicies", "title": "airlockpolicies", "description": "Retrieves the currently applied Airlock Policy for all groups from an Airlock Server via the REST API", "type": "customized", "parameters": [{"required": false, "name": "endpoint", "label": "Endpoint ", "default_value": "/v1/group", "placeholder": "", "help_string": "Note: This typically does not need to be modified for operation", "type": "text", "format_type": "text", "value": "/v1/group"}], "data_inputs_options": [{"type": "customized_var", "name": "endpoint", "title": "Endpoint ", "description": "Note: This typically does not need to be modified for operation", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "/v1/group", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport datetime\nimport json\n\ndef validate_input(helper, definition):\n    pass\n\ndef collect_events(helper, ew):\n\n    # The following examples get the arguments of this input.\n    # Note, for single instance mod input, args will be returned as a dict.\n    # For multi instance mod input, args will be returned as a single value.\n    opt_airlock_server_fqdn = helper.get_global_setting('airlock_server_fqdn')\n    opt_airlock_rest_api_port = helper.get_global_setting('airlock_rest_api_port')\n    opt_airlock_rest_api_key = helper.get_global_setting('airlock_rest_api_key')\n    #opt_verify_remote_tls_certificate = helper.get_global_setting('verify_remote_tls_certificate')    \n    helper.get_input_stanza()\n    # The following examples get options from setup page configuration.\n    # get the loglevel from the setup page\n    #loglevel = helper.get_log_level()\n    # get proxy setting configuration\n    proxy_settings = helper.get_proxy()\n    # get account credentials as dictionary\n    #account = helper.get_user_credential_by_username(\"username\")\n    #account = helper.get_user_credential_by_id(\"account id\")\n    # get global variable configuration\n    #global_userdefined_global_var = helper.get_global_setting(\"userdefined_global_var\")\n\n    #helper.set_log_level(log_level)\n\n    # The following examples send rest requests to some endpoint.\n    response = helper.send_http_request(\"https://\"+ opt_airlock_server_fqdn +\":\"+opt_airlock_rest_api_port+\"/v1/group\", method=\"POST\", parameters=None, headers={\"X-ApiKey\":opt_airlock_rest_api_key}, cookies=None, verify=True, cert=None,timeout=None, use_proxy=True)\n\n    r_json = response.json()\n\n    # check the response status, if the status is not sucessful, raise requests.HTTPError\n    response.raise_for_status()\n\n\n    for i in r_json['response']['groups']:\n        groupid=i['groupid']\n        response = helper.send_http_request(\"https://\"+ opt_airlock_server_fqdn +\":\"+opt_airlock_rest_api_port+\"/v1/group/policies\", method=\"POST\", parameters=None, payload={\"groupid\":groupid},headers={\"X-ApiKey\":opt_airlock_rest_api_key}, cookies=None, verify=True, cert=None,timeout=None, use_proxy=True)\n        \n        policy = response.json()\n        event = helper.new_event(source=\"Airlock_REST_policies\", index=helper.get_output_index(), sourcetype=\"_json\", data=json.dumps(policy),unbroken=True,time=time.time())\n        ew.write_event(event)", "customized_options": [{"name": "endpoint", "value": "/v1/group"}], "uuid": "7ae11d134a7747b7b02edbfd08e16f52"}]}, "global_settings_builder": {"global_settings": {"proxy_settings": {"proxy_type": "http"}, "log_settings": {"log_level": "DEBUG"}, "customized_settings": [{"required": true, "name": "airlock_server_fqdn", "label": "Airlock Server FQDN", "default_value": "", "placeholder": "airlock.server", "help_string": "", "type": "text", "format_type": "text", "value": ""}, {"required": true, "name": "airlock_rest_api_port", "label": "Airlock REST API Port", "default_value": "3129", "placeholder": "3129", "help_string": "", "type": "text", "format_type": "text", "value": "3129"}, {"required": true, "name": "airlock_rest_api_key", "label": "Airlock REST API Key", "placeholder": "", "default_value": "", "help_string": "You can obtain this key from Airlock by clicking your username in the top right hand corner of the web UI selecting My Profile. NOTE: You must have the generate_apikey permission to obtain a key.", "type": "password", "format_type": "password", "value": ""}]}}, "sourcetype_builder": {"airlockagent": {"metadata": {"event_count": 0, "data_input_name": "airlockagent", "extractions_count": 0, "cims_count": 0}}, "svractivities": {"metadata": {"event_count": 0, "data_input_name": "svractivities", "extractions_count": 0, "cims_count": 0}}, "exechistories": {"metadata": {"event_count": 0, "data_input_name": "exechistories", "extractions_count": 0, "cims_count": 0}}, "airlockpolicies": {"metadata": {"event_count": 0, "data_input_name": "airlockpolicies", "extractions_count": 0, "cims_count": 0}}}}